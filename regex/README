The regex module provides an implementation of regular expressions which adheres
closely to the POSIX Extended Regular Expressions (ERE) specification[0]. This
implementation computes matches in linear time.

By default, matches will be found anywhere in the given string. The ^ and $
characters can be used to anchor the match to the beginning or end of the
string.

find() returns a slice of [[matchgroup]]s for the first match. The first
[[matchgroup]] represents the entire match, while the rest represent the
submatches, specified in the expression using (parens).

findall() finds all non-overlapping matches in the given string and returns
a slice of slices of [[matchgroup]]s.

This module implements the POSIX match disambiguation rules by returning
the longest match among the leftmost matches.

	const re = regex::compile(`[Hh]are`)!;
	defer regex::regex_finish(&re);

	const first_match = regex::find(&re, "Hello Hare, hello Hare.")!;
	match (first_match) {
	case void => void;
	case let groups: []regex::matchgroup =>
		defer free(groups);
		// The match groups provide the content, start index and end
		// index of the main match, as well as all submatches.
		fmt::printfln("{} ({}, {})", groups[0].content,
			groups[0].start,
			groups[0].end)!;
	};

	const all_matches = regex::findall(&re, "Hello Hare, hello Hare.")!;
	match (all_matches) {
	case void => void;
	case let groupsets: [][]regex::matchgroup =>
		defer regex::freeall(groupsets);
		// A slice of multiple match group sets, which can be used
		// similarly to the find() example.
		for (let i = 0z; i < len(groupsets); i += 1) {
			fmt::printfln("{} ({}, {})", groupsets[i][0].content,
				groupsets[i][0].start,
				groupsets[i][0].end)!;
		};
	};

[0]: https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04
