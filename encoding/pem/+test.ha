// SPDX-License-Identifier: MPL-2.0
// (c) Hare authors <https://harelang.org>

use bytes;
use fmt;
use io;
use memio;
use strings;


@test fn read() void = {
	const testcert_str = fmt::asprintf(
		"garbage\ngarbage\ngarbage\n{}garbage\n", cert_str);
	defer free(testcert_str);
	const in = memio::fixed(strings::toutf8(testcert_str));
	const dec = newdecoder(&in);
	defer finish(&dec);

	const stream = next(&dec)! as (str, pemdecoder);
	assert(stream.0 == "CERTIFICATE");
	static let buf: [1024]u8 = [0...];
	assert(len(buf) >= len(testcert_bin));

	const data = io::drain(&stream.1)!;
	defer free(data);
	assert(bytes::equal(data, testcert_bin));

	assert(next(&dec) is io::EOF);
};

@test fn read_many() void = {
	const testmany = fmt::asprintf("{}{}", cert_str, privkey_str);
	defer free(testmany);
	const in = memio::fixed(strings::toutf8(testmany));
	const dec = newdecoder(&in);
	defer finish(&dec);

	static let buf: [1024]u8 = [0...];
	const stream = next(&dec)! as (str, pemdecoder);
	assert(stream.0 == "CERTIFICATE");
	const data = io::drain(&stream.1)!;
	defer free(data);
	assert(bytes::equal(data, testcert_bin));

	const stream = next(&dec)! as (str, pemdecoder);
	assert(stream.0 == "PRIVATE KEY");
	const data = io::drain(&stream.1)!;
	defer free(data);
	assert(bytes::equal(data, testprivkey_bin));

	assert(next(&dec) is io::EOF);
};

@test fn write() void = {
	let out = memio::dynamic();
	const stream = newencoder("CERTIFICATE", &out)!;
	io::writeall(&stream, testcert_bin)!;
	io::close(&stream)!;
	assert(memio::string(&out)! == cert_str);
	io::close(&out)!;

	let out = memio::dynamic();
	const stream = newencoder("PRIVATE KEY", &out)!;
	io::writeall(&stream, testprivkey_bin)!;
	io::close(&stream)!;
	assert(memio::string(&out)! == privkey_str);
	io::close(&out)!;

	// test short writes
	let out = memio::dynamic();
	const stream = newencoder("CERTIFICATE", &out)!;
	for (let i = 0z; i < len(testcert_bin); i += 1) {
		io::write(&stream, [testcert_bin[i]])!;
	};
	io::close(&stream)!;
	assert(memio::string(&out)! == cert_str);
	io::close(&out)!;
};

const cert_str: str =
`-----BEGIN CERTIFICATE-----
MIICLDCCAdKgAwIBAgIBADAKBggqhkjOPQQDAjB9MQswCQYDVQQGEwJCRTEPMA0G
A1UEChMGR251VExTMSUwIwYDVQQLExxHbnVUTFMgY2VydGlmaWNhdGUgYXV0aG9y
aXR5MQ8wDQYDVQQIEwZMZXV2ZW4xJTAjBgNVBAMTHEdudVRMUyBjZXJ0aWZpY2F0
ZSBhdXRob3JpdHkwHhcNMTEwNTIzMjAzODIxWhcNMTIxMjIyMDc0MTUxWjB9MQsw
CQYDVQQGEwJCRTEPMA0GA1UEChMGR251VExTMSUwIwYDVQQLExxHbnVUTFMgY2Vy
dGlmaWNhdGUgYXV0aG9yaXR5MQ8wDQYDVQQIEwZMZXV2ZW4xJTAjBgNVBAMTHEdu
dVRMUyBjZXJ0aWZpY2F0ZSBhdXRob3JpdHkwWTATBgcqhkjOPQIBBggqhkjOPQMB
BwNCAARS2I0jiuNn14Y2sSALCX3IybqiIJUvxUpj+oNfzngvj/Niyv2394BWnW4X
uQ4RTEiywK87WRcWMGgJB5kX/t2no0MwQTAPBgNVHRMBAf8EBTADAQH/MA8GA1Ud
DwEB/wQFAwMHBgAwHQYDVR0OBBYEFPC0gf6YEr+1KLlkQAPLzB9mTigDMAoGCCqG
SM49BAMCA0gAMEUCIDGuwD1KPyG+hRf88MeyMQcqOFZD0TbVleF+UsAGQ4enAiEA
l4wOuDwKQa+upc8GftXE2C//4mKANBC6It01gUaTIpo=
-----END CERTIFICATE-----
`;

const testcert_bin: [_]u8 = [
	0x30, 0x82, 0x02, 0x2c, 0x30, 0x82, 0x01, 0xd2, 0xa0, 0x03, 0x02, 0x01,
	0x02, 0x02, 0x01, 0x00, 0x30, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce,
	0x3d, 0x04, 0x03, 0x02, 0x30, 0x7d, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03,
	0x55, 0x04, 0x06, 0x13, 0x02, 0x42, 0x45, 0x31, 0x0f, 0x30, 0x0d, 0x06,
	0x03, 0x55, 0x04, 0x0a, 0x13, 0x06, 0x47, 0x6e, 0x75, 0x54, 0x4c, 0x53,
	0x31, 0x25, 0x30, 0x23, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x1c, 0x47,
	0x6e, 0x75, 0x54, 0x4c, 0x53, 0x20, 0x63, 0x65, 0x72, 0x74, 0x69, 0x66,
	0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72,
	0x69, 0x74, 0x79, 0x31, 0x0f, 0x30, 0x0d, 0x06, 0x03, 0x55, 0x04, 0x08,
	0x13, 0x06, 0x4c, 0x65, 0x75, 0x76, 0x65, 0x6e, 0x31, 0x25, 0x30, 0x23,
	0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x1c, 0x47, 0x6e, 0x75, 0x54, 0x4c,
	0x53, 0x20, 0x63, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74,
	0x65, 0x20, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x30,
	0x1e, 0x17, 0x0d, 0x31, 0x31, 0x30, 0x35, 0x32, 0x33, 0x32, 0x30, 0x33,
	0x38, 0x32, 0x31, 0x5a, 0x17, 0x0d, 0x31, 0x32, 0x31, 0x32, 0x32, 0x32,
	0x30, 0x37, 0x34, 0x31, 0x35, 0x31, 0x5a, 0x30, 0x7d, 0x31, 0x0b, 0x30,
	0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x42, 0x45, 0x31, 0x0f,
	0x30, 0x0d, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x06, 0x47, 0x6e, 0x75,
	0x54, 0x4c, 0x53, 0x31, 0x25, 0x30, 0x23, 0x06, 0x03, 0x55, 0x04, 0x0b,
	0x13, 0x1c, 0x47, 0x6e, 0x75, 0x54, 0x4c, 0x53, 0x20, 0x63, 0x65, 0x72,
	0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x61, 0x75, 0x74,
	0x68, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x31, 0x0f, 0x30, 0x0d, 0x06, 0x03,
	0x55, 0x04, 0x08, 0x13, 0x06, 0x4c, 0x65, 0x75, 0x76, 0x65, 0x6e, 0x31,
	0x25, 0x30, 0x23, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x1c, 0x47, 0x6e,
	0x75, 0x54, 0x4c, 0x53, 0x20, 0x63, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69,
	0x63, 0x61, 0x74, 0x65, 0x20, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69,
	0x74, 0x79, 0x30, 0x59, 0x30, 0x13, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce,
	0x3d, 0x02, 0x01, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01,
	0x07, 0x03, 0x42, 0x00, 0x04, 0x52, 0xd8, 0x8d, 0x23, 0x8a, 0xe3, 0x67,
	0xd7, 0x86, 0x36, 0xb1, 0x20, 0x0b, 0x09, 0x7d, 0xc8, 0xc9, 0xba, 0xa2,
	0x20, 0x95, 0x2f, 0xc5, 0x4a, 0x63, 0xfa, 0x83, 0x5f, 0xce, 0x78, 0x2f,
	0x8f, 0xf3, 0x62, 0xca, 0xfd, 0xb7, 0xf7, 0x80, 0x56, 0x9d, 0x6e, 0x17,
	0xb9, 0x0e, 0x11, 0x4c, 0x48, 0xb2, 0xc0, 0xaf, 0x3b, 0x59, 0x17, 0x16,
	0x30, 0x68, 0x09, 0x07, 0x99, 0x17, 0xfe, 0xdd, 0xa7, 0xa3, 0x43, 0x30,
	0x41, 0x30, 0x0f, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x01, 0x01, 0xff, 0x04,
	0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30, 0x0f, 0x06, 0x03, 0x55, 0x1d,
	0x0f, 0x01, 0x01, 0xff, 0x04, 0x05, 0x03, 0x03, 0x07, 0x06, 0x00, 0x30,
	0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0xf0, 0xb4,
	0x81, 0xfe, 0x98, 0x12, 0xbf, 0xb5, 0x28, 0xb9, 0x64, 0x40, 0x03, 0xcb,
	0xcc, 0x1f, 0x66, 0x4e, 0x28, 0x03, 0x30, 0x0a, 0x06, 0x08, 0x2a, 0x86,
	0x48, 0xce, 0x3d, 0x04, 0x03, 0x02, 0x03, 0x48, 0x00, 0x30, 0x45, 0x02,
	0x20, 0x31, 0xae, 0xc0, 0x3d, 0x4a, 0x3f, 0x21, 0xbe, 0x85, 0x17, 0xfc,
	0xf0, 0xc7, 0xb2, 0x31, 0x07, 0x2a, 0x38, 0x56, 0x43, 0xd1, 0x36, 0xd5,
	0x95, 0xe1, 0x7e, 0x52, 0xc0, 0x06, 0x43, 0x87, 0xa7, 0x02, 0x21, 0x00,
	0x97, 0x8c, 0x0e, 0xb8, 0x3c, 0x0a, 0x41, 0xaf, 0xae, 0xa5, 0xcf, 0x06,
	0x7e, 0xd5, 0xc4, 0xd8, 0x2f, 0xff, 0xe2, 0x62, 0x80, 0x34, 0x10, 0xba,
	0x22, 0xdd, 0x35, 0x81, 0x46, 0x93, 0x22, 0x9a,
];

const privkey_str: str =
`-----BEGIN PRIVATE KEY-----
MIGEAgEAMBAGByqGSM49AgEGBSuBBAAKBG0wawIBAQQgVcB/UNPxalR9zDYAjQIf
jojUDiQuGnSJrFEEzZPT/92hRANCAASc7UJtgnF/abqWM60T3XNJEzBv5ez9TdwK
H0M6xpM2q+53wmsN/eYLdgtjgBd3DBmHtPilCkiFICXyaA8z9LkJ
-----END PRIVATE KEY-----
`;

const testprivkey_bin: [_]u8 = [
	0x30, 0x81, 0x84, 0x02, 0x01, 0x00, 0x30, 0x10, 0x06, 0x07, 0x2a, 0x86,
	0x48, 0xce, 0x3d, 0x02, 0x01, 0x06, 0x05, 0x2b, 0x81, 0x04, 0x00, 0x0a,
	0x04, 0x6d, 0x30, 0x6b, 0x02, 0x01, 0x01, 0x04, 0x20, 0x55, 0xc0, 0x7f,
	0x50, 0xd3, 0xf1, 0x6a, 0x54, 0x7d, 0xcc, 0x36, 0x00, 0x8d, 0x02, 0x1f,
	0x8e, 0x88, 0xd4, 0x0e, 0x24, 0x2e, 0x1a, 0x74, 0x89, 0xac, 0x51, 0x04,
	0xcd, 0x93, 0xd3, 0xff, 0xdd, 0xa1, 0x44, 0x03, 0x42, 0x00, 0x04, 0x9c,
	0xed, 0x42, 0x6d, 0x82, 0x71, 0x7f, 0x69, 0xba, 0x96, 0x33, 0xad, 0x13,
	0xdd, 0x73, 0x49, 0x13, 0x30, 0x6f, 0xe5, 0xec, 0xfd, 0x4d, 0xdc, 0x0a,
	0x1f, 0x43, 0x3a, 0xc6, 0x93, 0x36, 0xab, 0xee, 0x77, 0xc2, 0x6b, 0x0d,
	0xfd, 0xe6, 0x0b, 0x76, 0x0b, 0x63, 0x80, 0x17, 0x77, 0x0c, 0x19, 0x87,
	0xb4, 0xf8, 0xa5, 0x0a, 0x48, 0x85, 0x20, 0x25, 0xf2, 0x68, 0x0f, 0x33,
	0xf4, 0xb9, 0x09,
];

@test fn readcrlf() void = {
	const test_str = fmt::asprintf(
		"garbage\r\ngarbage\r\ngarbage\r\n{}garbage\r\n", testcrlf_str);
	defer free(test_str);
	const in = memio::fixed(strings::toutf8(test_str));
	const dec = newdecoder(&in);
	defer finish(&dec);

	const stream = next(&dec)! as (str, pemdecoder);
	assert(stream.0 == "TEST");
	static let buf: [1024]u8 = [0...];
	assert(len(buf) >= len(testcert_bin));

	const data = io::drain(&stream.1)!;
	defer free(data);
	assert(bytes::equal(data, testcrlf_bin));

	assert(next(&dec) is io::EOF);
};

const testcrlf_str: str = "-----BEGIN TEST-----\r\ndGVzdA==\r\n-----END TEST-----\r\n";
const testcrlf_bin: [_]u8 = [0x74, 0x65, 0x73, 0x74];
